name: Update Python Dependencies

on:
  schedule:
    - cron: '0 0 1 1,7 *'  # Runs every 6 months (Jan 1st and July 1st) at midnight UTC
  workflow_dispatch:    # Allows manual triggering of the workflow

permissions:
  contents: write        # Allows the workflow to commit and push changes

jobs:
  update_dependencies:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v6.0.0
        with:
          fetch-depth: 0  # Ensure the entire history is fetched

      # Step 2: Set up Python
      - name: Set up Python
        uses: actions/setup-python@v6.0.0
        with:
          python-version: '3.13'  # Use a stable Python version

      # Step 3: Install system dependencies
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libxml2-dev libxslt-dev zlib1g-dev

      # Step 4: Install Pipenv and pip-tools
      - name: Install dependency tools
        run: |
          pip install --upgrade pip setuptools wheel
          pip install pipenv pip-tools

      # Step 5: Configure Git
      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      # Step 6: Find and update all dependency files
      - name: Update all Python dependencies
        id: update_deps
        run: |
          # Exit immediately if a command exits with a non-zero status
          set -e
          UPDATED_COUNT=0
          INITIAL_DIR=$(pwd)
          
          # Use a temporary file to store the list of directories
          # This avoids pipe subshell issues with 'set -e'
          find . -type f \( -name "Pipfile" -o -name "requirements.txt" \) -not -path "*/\.*" -not -path "*/node_modules/*" -exec dirname {} \; | sort -u > directories.txt
          
          while IFS= read -r dir; do
            if [ -z "$dir" ]; then
              continue
            fi
            
            echo "========================================="
            echo "Processing: $dir"
            echo "========================================="
            
            cd "$INITIAL_DIR/$dir"
            
            # Handle Pipfile
            if [ -f "Pipfile" ]; then
              echo "Found Pipfile, updating dependencies..."
              
              # Update python_version in Pipfile to match runner (3.13)
              if grep -q "python_version" Pipfile; then
                  echo "Updating Python version in Pipfile to 3.13..."
                  sed -i 's/python_version = ".*"/python_version = "3.13"/' Pipfile
              fi
              
              # Set environment variables for non-interactive pipenv
              export PIPENV_VENV_IN_PROJECT=1
              export PIPENV_YES=1
              
              # Clean any existing virtual environment
              pipenv --rm || true
              pipenv --clear || true
              rm -rf .venv
              
              # Try to install dependencies to set up the environment
              echo "Attempting pipenv install..."
              
              # We use a custom install process to ensure build deps are present
              # 1. Create the venv explicitly first
              python3 -m venv .venv
              
              # 2. Install build tools INSIDE the venv
              ./.venv/bin/pip install --upgrade pip setuptools wheel
              
              # 3. Use pipenv to install dependencies using this venv
              # Use --skip-lock because we just modified Pipfile (potentially) so lock is stale
              if ! pipenv install --dev --skip-lock; then
                echo "Standard install failed. Stopping workflow."
                exit 1
              fi
              
              # Update all packages
              echo "Running pipenv update..."
              if pipenv update --clear; then
                # Ensure lock file is synced/generated
                echo "Syncing lock file..."
                pipenv lock
                
                # Check if files changed
                if [ -f "Pipfile.lock" ]; then
                  git add Pipfile Pipfile.lock
                  UPDATED_COUNT=$((UPDATED_COUNT + 1))
                  echo "✓ Updated Pipfile and Pipfile.lock"
                fi
              else
                echo "Failed to update Pipfile dependencies. Stopping workflow."
                exit 1
              fi
              
              # Clean up virtual environment
              pipenv --rm || true
              rm -rf .venv
            fi
            
            # Handle requirements.txt
            if [ -f "requirements.txt" ]; then
              echo "Found requirements.txt, updating dependencies..."
              
              # Create a unique virtual environment name
              VENV_NAME=$(echo "$dir" | tr '/' '_' | tr ' ' '_' | sed 's/^\._//')
              VENV_PATH="/tmp/venv_${VENV_NAME}"
              
              # Create temporary virtual environment
              python3 -m venv "$VENV_PATH"
              
              source "$VENV_PATH/bin/activate"
              
              # Upgrade pip and build tools
              pip install --quiet --upgrade pip setuptools wheel
              
              # Check if requirements.in exists (for pip-compile workflow)
              if [ -f "requirements.in" ]; then
                pip install --quiet pip-tools
                echo "Compiling requirements.in..."
                if pip-compile --upgrade requirements.in; then
                  git add requirements.txt requirements.in
                  UPDATED_COUNT=$((UPDATED_COUNT + 1))
                  echo "✓ Updated requirements.txt from requirements.in"
                else
                  echo "Failed to compile requirements.in. Stopping workflow."
                  exit 1
                fi
              else
                # Install current requirements
                echo "Installing current requirements..."
                if ! pip install --quiet -r requirements.txt; then
                   echo "Failed to install initial requirements. Stopping workflow."
                   exit 1
                fi
                
                # Try to update packages
                echo "Checking for updates..."
                if ! pip install --quiet --upgrade -r requirements.txt; then
                   echo "Failed to upgrade requirements. Stopping workflow."
                   exit 1
                fi
                
                # Generate new requirements.txt
                pip freeze > requirements.txt.new
                
                if [ -f "requirements.txt.new" ] && ! diff -q requirements.txt requirements.txt.new > /dev/null 2>&1; then
                  mv requirements.txt.new requirements.txt
                  git add requirements.txt
                  UPDATED_COUNT=$((UPDATED_COUNT + 1))
                  echo "✓ Updated requirements.txt"
                else
                  rm -f requirements.txt.new
                  echo "No updates needed for requirements.txt"
                fi
              fi
              
              deactivate
              rm -rf "$VENV_PATH"
            fi
            
            cd "$INITIAL_DIR"
            echo ""
          done < directories.txt
          
          # Set output variables
          if [ $UPDATED_COUNT -gt 0 ]; then
            echo "updated=true" >> $GITHUB_OUTPUT
            echo "files_count=$UPDATED_COUNT" >> $GITHUB_OUTPUT
            echo "Successfully updated $UPDATED_COUNT dependency files"
          else
            echo "updated=false" >> $GITHUB_OUTPUT
            echo "files_count=0" >> $GITHUB_OUTPUT
            echo "No dependency files were updated"
          fi

      # Step 7: Commit the changes and set an output if a commit was made
      - name: Commit changes
        id: commit
        run: |
          if [ "${{ steps.update_deps.outputs.updated }}" == "true" ]; then
            # Check if there are any staged changes
            git add -A
            if ! git diff --staged --quiet; then
              git commit -m "Automated update of Python dependencies across all folders (${{ steps.update_deps.outputs.files_count }} files updated)"
              echo "commit=true" >> $GITHUB_OUTPUT
              echo "Committed changes to ${{ steps.update_deps.outputs.files_count }} files"
            else
              echo "commit=false" >> $GITHUB_OUTPUT
              echo "No changes to commit (files may have been already up to date)"
            fi
          else
            echo "commit=false" >> $GITHUB_OUTPUT
            echo "No dependencies were updated"
          fi

      # Step 8: Push changes (only if a commit was made)
      - name: Push changes
        if: steps.commit.outputs.commit == 'true'
        run: git push origin main
